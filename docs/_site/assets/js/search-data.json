{"0": {
    "doc": "SF<sub>6</sub>O<sub>2</sub> Etching",
    "title": "SF6O2 Etching",
    "content": "#include &lt;psSF6O2Etching.hpp&gt; . The model for SF6O2 etching of silicon is based on a model by Belen et al. 1 and summarized here. For implementation details refer to here. To describe the feature scale simulation of SF6O2 plasma etching, the surface rates of both ions and neutral particles, specifically fluorine and oxygen, and the surface coverages of neutrals, are considered. Ray tracing is used for the calculation of the surface rates, which are used for calculating coverages during each time step. The etch rate is determined the three physical phenomena: . | Chemical etching | Physical sputtering | Ion-enhanced etching | . In the process of chemical etching, the fluorine from the SF6 species reacts with the exposed silicon surface. Physical sputtering is caused by high-energy ions impacting the surface. Due to an applied bias, ions strike the wafer surface with a high enough kinetic energy, $E_{ion} &gt; E_{th}$ to break the existing bonds in the silicon wafer or other exposed materials. Lastly, ion-enhanced etching, also known as reactive ion etching (RIE), combines the two previous effects. Since silicon surfaces that are saturated with fluorine are more prone to physical sputtering, the threshold energy for releasing the silicon atom $E_{th}$ is significantly reduced compared to non-fluorinated surfaces. Therefore, ion-enhanced etching provides an etch rate that is larger than the sum of the chemical etching and sputtering. The surface can be covered in fluorine or oxygen. The physical model keeps track of these coverages, given by $\\theta_F$ and $\\theta_O$, respectively, by calculating the flux-induced rates and considering the coverages from the previous time step. They are calculated with Langmuir–Hinshelwood-type surface site balance equations, given by: . \\begin{equation} \\sigma_{Si}\\cfrac{d\\theta_{F}}{dt}=\\gamma_{F}\\Gamma_{F}\\left(1-\\theta_{F}-\\theta_{O}\\right)-k\\sigma_{Si}\\theta_{F}-2Y_{ie}\\Gamma_{i}\\theta_{F} \\label{equ:thetaF} \\end{equation} . \\begin{equation} \\sigma_{Si}\\cfrac{d\\theta_{O}}{dt}=\\gamma_{O}\\Gamma_{O}\\left(1-\\theta_{F}-\\theta_{O}\\right)-\\beta\\sigma_{Si}\\theta_{O}-Y_{O}\\Gamma_{i}\\theta_{O} \\label{equ:thetaO} \\end{equation} . The term $\\sigma_{Si}$ represents the density of silicon at the surface point $\\vec{x}$ which is not included in the equations for legibility; $\\Gamma_F$, $\\Gamma_O$, and $\\Gamma_i$ are the emitted fluorine, oxygen, and ion fluxes, respectively; $\\gamma_F$ and $\\gamma_O$ are the sticking coefficients for fluorine and oxygen on a non-covered silicon substrate, respectively; $k$ is the chemical etch reaction rate constant; $\\beta$ is the oxygen recombination rate constant; and $Y_{ie}$ and $Y_O$ are the total ion-enhanced and oxygen etching yields, respectively. $Y_{ie}$ and $Y_O$ are yield functions that are dependent on the ion energies in the reactor. Since the surface movement is significantly smaller than the considered fluxes, it can be assumed that it does not impact the calculation. With this assumption of a pseudo-steady-state, the coverage equations can be set equal to zero, resulting in the following surface coverage equations: \\begin{equation} \\theta_{F}=\\left[1+\\left(\\cfrac{k\\sigma_{Si}+2Y_{ie}\\Gamma_{i}}{\\gamma_{F}\\Gamma_{F}}\\right)\\left(1+\\cfrac{\\gamma_{O}\\Gamma_{O}}{\\beta\\sigma_{Si}+Y_{O}\\Gamma_{i}}\\right)\\right]^{-1} \\end{equation} . \\begin{equation} \\theta_{O}=\\left[1+\\left(\\cfrac{\\beta\\sigma_{Si}+Y_{ie}\\Gamma_{i}}{\\gamma_{O}\\Gamma_{O}}\\right)\\left(1+\\cfrac{\\gamma_{F}\\Gamma_{F}}{k\\sigma_{Si}+2Y_{ie}\\Gamma_{i}}\\right)\\right]^{-1} \\end{equation} . The reason that pseudo-steady-state can be assumed is that the incoming fluxes of all involved particles are in the order of 10$^{16}$–10$^{19}$ cm-1s-1, which is significantly larger than the surface etch rate ER, which is typically in the range of several nanometers per second. The oxygen particles do not take part in surface removal; instead, they occupy an area on the top surface layer and inhibit the effects of chemical etching by fluorine. Relating it to the parameters in the equation, the presence of oxygen (denoted by its flux $\\Gamma_{O}$) tends to reduce $\\theta_{F}$. Increasing the oxygen flux $\\Gamma_O$ increases the overall expression in the square brackets, which means $\\theta_{F}$ decreases. Since oxygen has a passivating effect, the etching of silicon proceeds only due to its reaction with fluorine and physical sputtering due to the incoming ion flux. At locations where oxygen coverage is high, only ion sputtering takes place. This brings us to the expression for the etch rate (ER), which is used to move the surface . \\begin{equation} \\textrm{ER}=\\cfrac{1}{\\rho_{Si}}\\left(\\cfrac{k\\sigma_{Si}\\theta_{F}}{4}+Y_{p}\\Gamma_{i}+Y_{ie}\\Gamma_{i}\\theta_{F}\\right), \\end{equation} where $\\rho_{Si}$ is the silicon density. The first, second, and third terms in the brackets of the etch rate equation represent the chemical etching, physical sputtering, and ion-enhanced etching, respectively. ",
    "url": "/models/prebuilt/SF6O2Etching.html#sf6o2-etching",
    
    "relUrl": "/models/prebuilt/SF6O2Etching.html#sf6o2-etching"
  },"1": {
    "doc": "SF<sub>6</sub>O<sub>2</sub> Etching",
    "title": "Ions",
    "content": "Each ion is endowed with an initial energy and direction upon creation on the source plane. The assignment of initial energies is governed by a normal distribution, characterized by a mean energy value and an energy sigma, thus allowing for stochastic variations in the initial energy states of the ions. The distribution of initial ion directions is given by a power cosine source distribution, which is defined by the exponent of the power cosine distribution. Upon impact with the surface, an energy- and angle-dependent yield is computed, which contributes to the specific surface point’s rate. The yield is expressed as: \\begin{equation} Y(E,\\theta) = A\\left(\\sqrt{E} - \\sqrt{E_{th}}\\right)f(\\theta), \\end{equation} where $E$ denotes the particle energy and $\\theta$ its incident angle. Here, $A$ represents a yield coefficient, and $E_{\\text{th}}$ denotes the material’s threshold energy for physical sputtering. The function $f(\\theta)$, which characterizes the angle-dependence of the yield. For sputtering, the function is given by: \\begin{equation} f(\\theta) = (1 + B_{sp}(1-\\cos^2(\\theta)))\\cos(\\theta), \\end{equation} while for ion-enhanced etching, the function is given by: \\begin{equation} f(\\theta) = \\cos(\\theta). \\end{equation} . The ions can also reflect from the surface. Their energy loss during reflection is described by the model proposed by Belen et al 1. The current ray energy is multiplied by a factor $E_\\textrm{ref}$ ($0 \\leq E_\\textrm{ref} \\leq 1$) which depends on the incoming angle $\\theta$ in the following way: \\begin{equation} E_{\\textrm{ref}}= 1-(1-A)\\frac{\\frac{\\pi}{2}-\\theta}{\\frac{\\pi}{2}-\\theta_\\textrm{inflect}} \\quad \\text{ if } \\theta \\geqslant \\theta_\\textrm{inflect} \\end{equation} \\begin{equation} E_{\\textrm{ref}}=\\mathrm{A}\\left(\\frac{\\theta}{\\theta_\\textrm{inflect}}\\right)^{n_l} \\quad \\text{ if } \\theta&lt;\\theta_\\textrm{inflect}, \\end{equation} where $A = (1 + n(\\frac{\\pi}{2 \\theta_\\textrm{inflect}} - 1))^{-1}$. Ions striking the surface at an angle denoted by $\\theta$ relative to the surface normal undergo reflection, where the angular dispersion is characterized by a cosine function centered around the direction of specular reflection defined by $\\theta_\\textrm{spec}$. This reflection process distinguishes between ions approaching the surface at glancing angles, which undergo nearly perfect specular reflection, and those striking the surface perpendicularly, which undergo nearly diffuse reflection. \\begin{equation} \\mathrm{P}(\\phi) \\propto \\cos \\left(\\frac{\\pi}{2} \\frac{\\phi}{\\frac{\\pi}{2}-\\theta_\\textrm{spec}}\\right) \\quad \\text{ if } \\theta_\\textrm{inc} \\leqslant \\theta_\\textrm{min} \\end{equation} . \\begin{equation} \\mathrm{P}(\\phi) \\propto \\cos \\left(\\frac{\\pi}{2} \\frac{\\phi}{\\frac{\\pi}{2}-\\theta_\\textrm{min}}\\right) \\quad \\text{ if } \\theta_{\\textrm{inc}}&gt;\\theta_{\\textrm{min}} \\end{equation} . The ray’s reflected direction is randomly chosen from a cone around the specular direction. The opening angle of this cone is given by the incidence angle $\\theta$. ",
    "url": "/models/prebuilt/SF6O2Etching.html#ions",
    
    "relUrl": "/models/prebuilt/SF6O2Etching.html#ions"
  },"2": {
    "doc": "SF<sub>6</sub>O<sub>2</sub> Etching",
    "title": "Implementation",
    "content": "psSF6O2Etching(const double ionFlux, const double etchantFlux, const double oxygenFlux, const NumericType meanEnergy /* eV */, const NumericType sigmaEnergy /* eV */, const NumericType ionExponent = 100., const NumericType oxySputterYield = 2., const NumericType etchStopDepth = std::numeric_limits&lt;NumericType&gt;::lowest()) . | Parameter | Description | Type | . | ionFlux | Ion flux for the SF6O2 etching process. | double | . | etchantFlux | Etchant flux for the SF6O2 etching process. | double | . | oxygenFlux | Oxygen flux for the SF6O2 etching process. | double | . | meanEnergy | Mean energy of ions in electronvolts (eV). | NumericType | . | sigmaEnergy | Energy distribution standard deviation in electronvolts (eV). | NumericType | . | ionExponent | (Optional) Exponent in the power cosine source distribution of ions for initial directions. Default is set to 100. | NumericType | . | oxySputterYield | (Optional) Oxygen sputtering yield. Default is set to 2. | NumericType | . | etchStopDepth | (Optional) Depth at which etching should stop. Default is negative infinity. | NumericType | . All flux values are units 1016 / cm2. Alternatively, users can access and modify all detailed parameters by retrieving the parameter struct, which encapsulates the following values: . | Parameter | Description | Default Value | . | ionFlux | Ion flux (1016 /cm² /s) | 12.0 | . | etchantFlux | Etchant flux (1016 /cm² /s) | 1800.0 | . | oxygenFlux | Oxygen flux (1016 /cm² /s) | 100.0 | . | etchStopDepth | Depth at which etching stops | -inf | . | beta_F | Sticking probability for fluorine | 0.7 | . | beta_O | Sticking probability for oxygen | 1.0 | . | Mask.rho | Mask density (1022 atoms/cm³) | 500.0 | . | Mask.beta_F | Mask sticking probability for fluorine | 0.01 | . | Mask.beta_O | Mask sticking probability for oxygen | 0.1 | . | Mask.Eth_sp | Mask sputtering threshold energy (eV) | 20.0 | . | Mask.A_sp | Mask sputtering coefficient | 0.0139 | . | Mask.B_sp | Mask sputtering coefficient | 9.3 | . | Si.rho | Silicon density (1022 atoms/cm³) | 5.02 | . | Si.Eth_sp | Silicon sputtering threshold energy (eV) | 20.0 | . | Si.Eth_ie | Silicon ion enhanced etching threshold energy (eV) | 4.0 | . | Si.A_sp | Silicon sputtering coefficient | 0.0337 | . | Si.B_sp | Silicon sputtering coefficient | 9.3 | . | Si.A_ie | Silicon ion enhanced etching coefficient | 0.0361 | . | Si.k_sigma | Silicon chemical etching coefficient | 300.0 | . | Si.beta_sigma | Silicon chemical etching coefficient | 0.05 | . | Passivation.Eth_ie | Passivation ion enhanced etching threshold energy (eV) | 4.0 | . | Passivation.A_ie | Passivation ion enhanced etching coefficient | 0.0361 | . | Ions.meanEnergy | Mean ion energy (eV) | 100.0 | . | Ions.sigmaEnergy | Standard deviation of ion energy (eV) | 10.0 | . | Ions.exponent | Exponent of power cosine source distribution of initial ion directions | 500.0 | . | Ions.inflectAngle | Inflection angle | 1.55334303 | . | Ions.n_l | Exponent of reflection power | 10.0 | . | Ions.minAngle | Minimum cone angle for ion reflection | 1.3962634 | . Example usage: . C++ ... auto model = psSmartPointer&lt;psSF6O2Etching&lt;NumericType, D&gt;&gt;::New(); auto &amp;parameters = model-&gt;getParameters(); parameters.ionFlux = 10.; parameters.Mask.rho = 500.; // this modifies a direct reference of the parameters ... Python ... model = vps.SF6O2Etching() parameters = model.getParameters() parameters.ionFlux = 10. parameters.Mask.rho = 500. # this modifies a direct reference of the parameters ... ",
    "url": "/models/prebuilt/SF6O2Etching.html#implementation",
    
    "relUrl": "/models/prebuilt/SF6O2Etching.html#implementation"
  },"3": {
    "doc": "SF<sub>6</sub>O<sub>2</sub> Etching",
    "title": "Related Examples",
    "content": ". | Hole Etching | . | Rodolfo Jun Belen, Sergi Gomez, Mark Kiehlbauch, David Cooperberg, Eray S. Aydil; Feature-scale model of Si etching in SF6 plasma and comparison with experiments. J. Vac. Sci. Technol. A 1 January 2005; 23 (1): 99–113. https://doi.org/10.1116/1.1830495 &#8617; &#8617;2 . | . ",
    "url": "/models/prebuilt/SF6O2Etching.html#related-examples",
    
    "relUrl": "/models/prebuilt/SF6O2Etching.html#related-examples"
  },"4": {
    "doc": "SF<sub>6</sub>O<sub>2</sub> Etching",
    "title": "SF<sub>6</sub>O<sub>2</sub> Etching",
    "content": " ",
    "url": "/models/prebuilt/SF6O2Etching.html",
    
    "relUrl": "/models/prebuilt/SF6O2Etching.html"
  },"5": {
    "doc": "TEOS Deposition",
    "title": "TEOS Deposition",
    "content": "#include &lt;psTEOSDeposition.hpp&gt; . Coming soon . ",
    "url": "/models/prebuilt/TEOSDeposition.html",
    
    "relUrl": "/models/prebuilt/TEOSDeposition.html"
  },"6": {
    "doc": "TEOS Deposition",
    "title": "Related Examples",
    "content": ". | TEOS Trench Deposition | . ",
    "url": "/models/prebuilt/TEOSDeposition.html#related-examples",
    
    "relUrl": "/models/prebuilt/TEOSDeposition.html#related-examples"
  },"7": {
    "doc": "Advection Callback",
    "title": "Advection Callback",
    "content": ". Coming soon . ",
    "url": "/models/custom/advectionCallback.html",
    
    "relUrl": "/models/custom/advectionCallback.html"
  },"8": {
    "doc": "Anisotropic Process",
    "title": "Anisotropic Process",
    "content": "#include &lt;psAnisotropicProcess.hpp&gt; . Coming soon . ",
    "url": "/models/prebuilt/anisotropic.html",
    
    "relUrl": "/models/prebuilt/anisotropic.html"
  },"9": {
    "doc": "Anisotropic Process",
    "title": "Related Examples",
    "content": ". | Cantilever Wet Etching | Selective Epitaxy | . ",
    "url": "/models/prebuilt/anisotropic.html#related-examples",
    
    "relUrl": "/models/prebuilt/anisotropic.html#related-examples"
  },"10": {
    "doc": "Custom Geometry",
    "title": "Custom Geometry using ViennaLS",
    "content": ". ViennaPS offers the capability to create custom geometries using tools from the ViennaLS library. The lsMakeGeometry function provides functionality for constructing basic geometric shapes like boxes, spheres, or cylinders. Moreover, shapes can be formed by creating a convex hull over a point cloud or by explicitly defining points and elements of a structure. Subsequently, boolean operations such as union, intersect, and relative complement can be applied to merge these basic shapes into a customized geometry. This flexible approach enables users to create complex geometries tailored to their specific simulation requirements. Some examples are provided below: . Examples: . Coming soon . ",
    "url": "/geo/custom.html#custom-geometry-using-viennals",
    
    "relUrl": "/geo/custom.html#custom-geometry-using-viennals"
  },"11": {
    "doc": "Custom Geometry",
    "title": "Custom Geometry",
    "content": " ",
    "url": "/geo/custom.html",
    
    "relUrl": "/geo/custom.html"
  },"12": {
    "doc": "Directional Etching",
    "title": "Directional Etching",
    "content": "#include &lt;psDirectionalEtching.hpp&gt; . Details Coming soon . psDirectionalEtching(const std::array&lt;NumericType, 3&gt; &amp;direction, const NumericType directionalVelocity = 1., const NumericType isotropicVelocity = 0., const psMaterial mask = psMaterial::Mask) . | Parameter | Description | Type | . | direction | Direction vector for directional etching. | std::array&lt;NumericType, 3&gt; | . | directionalVelocity | (Optional) Velocity for directional etching. Default is set to 1. | NumericType | . | isotropicVelocity | (Optional) Isotropic velocity for etching. Default is set to 0. | NumericType | . | mask | (Optional) Material used as a mask. Default is set to psMaterial::Mask. | psMaterial | . ",
    "url": "/models/prebuilt/directional.html",
    
    "relUrl": "/models/prebuilt/directional.html"
  },"13": {
    "doc": "Disk Mesh",
    "title": "Disk Mesh",
    "content": ". Coming soon . ",
    "url": "/output/disk.html",
    
    "relUrl": "/output/disk.html"
  },"14": {
    "doc": "Geometry Extrusion",
    "title": "Extrude a Geometry from 2D to 3D",
    "content": ". Extrude a 2D domain into 3D, allowing users to define the extrusion direction and extent. Additionally, users have the flexibility to specify the boundary conditions for the extruded domain. Example usage: . C++ . psExtrude&lt;double&gt;(domain2D, domain3D, {0., 1.}, // min and max extent in the extruded dim 2, // extrude in z-direction {lsBoundaryConditionEnum::REFLECTIVE, lsBoundaryConditionEnum::REFLECTIVE, lsBoundaryConditionEnum::INFINITE_BOUNDARY}).apply(); . Since the ViennaPS 2D and 3D libraries cannot be used together in Python, this feature is currently not available in the Python bindings. ",
    "url": "/misc/extrusion.html#extrude-a-geometry-from-2d-to-3d",
    
    "relUrl": "/misc/extrusion.html#extrude-a-geometry-from-2d-to-3d"
  },"15": {
    "doc": "Geometry Extrusion",
    "title": "Geometry Extrusion",
    "content": " ",
    "url": "/misc/extrusion.html",
    
    "relUrl": "/misc/extrusion.html"
  },"16": {
    "doc": "Fin Geometry",
    "title": "Fin Geometry",
    "content": "#include &lt;psMakeFin.hpp&gt; . The psMakeFin class generates a fin geometry extending in the z (3D) or y (2D) direction, centered at the origin with specified dimensions in the x and y directions. The fin may incorporate periodic boundaries in the x and y directions (limited to 3D). Users can define the width and height of the fin, and it can function as a mask, with the specified material exclusively applied to the bottom of the fin, while the upper portion adopts the mask material. psMakeFin(psDomainType domain, const NumericType gridDelta, const NumericType xExtent, const NumericType yExtent, const NumericType finWidth, const NumericType finHeight, const NumericType baseHeight = 0., const bool periodicBoundary = false, const bool makeMask = false, const psMaterial material = psMaterial::None) . | Parameter | Description | Type | . | domain | Specifies the type of domain for the fin geometry. | psSmartPointer&lt;psDomain&lt;NumericType, D&gt; | . | gridDelta | Represents the grid spacing or resolution used in the simulation. | NumericType | . | xExtent | Defines the extent of the fin geometry in the x-direction. | NumericType | . | yExtent | Specifies the extent of the fin geometry in the y-direction. | NumericType | . | finWidth | Sets the width of the fin. | NumericType | . | finHeight | Determines the height of the fin. | NumericType | . | baseHeight | (Optional) Sets the base height of the fin. Default is set to 0. | NumericType | . | periodicBoundary | (Optional) If set to true, enables periodic boundaries in both x and y directions. Default is set to false. | bool | . | makeMask | (Optional) If set to true, allows the fin to function as a mask, with specified material applied only to the bottom. Default is set to false. | bool | . | material | (Optional) Specifies the material used for the fin. Default is set to psMaterial_None. | psMaterial | . Example usage: . C++ . auto domain = psSmartPointer&lt;psDomain&lt;NumericType, D&gt;&gt;::New(); psMakeFin&lt;NumericType, D&gt;(domain, 0.5, 10.0, 10.0, 5.0, 5.0, 0., false, false, psMaterial::Si) .apply(); . Python: . domain = vps.Domain() vps.MakeFin(domain=domain, gridDelta=0.5, xExtent=10.0, yExtent=10.0, finWidth=2.5, finHeight=5.0, baseHeight=0.0, periodicBoundary=False, makeMask=False, material=vps.Material.Si, ).apply() . ",
    "url": "/geo/basic/fin.html",
    
    "relUrl": "/geo/basic/fin.html"
  },"17": {
    "doc": "Fluorocarbon Etching",
    "title": "Fluorocarbon Etching",
    "content": "#include &lt;psFluorocarbonEtching.hpp&gt; . Our model assumes that, in any complex plasma etch process, there are four fundamental types of particles: neutral, etchant, depositing polymer particles and ions. Due to the long etch times, compared to surface reaction time scales, we can safely assume that each of these substances’ concentrations will reach a steady state on the surface. Therefore, the surface coverages of all involved particle types $\\phi_x$, where $x$ represents etchant (e), polymer (p), etchant on polymer (ep), and ions (i), are expressed by the following equations: \\begin{equation} \\frac{d \\phi_e}{dt}=J_{e} S_{e}\\left(1-\\phi_{e}-\\phi_{p}\\right)-k_{i e} J_{i} Y_{ie} \\phi_{e}-k_{e v} J_{e v} \\phi_{e} \\approx 0; \\end{equation} \\begin{equation} \\frac{d \\phi_{p}}{d t}=J_{p} S_{p}-J_{i} Y_{p} \\phi_{p} \\phi_{p e} \\approx 0; \\end{equation} \\begin{equation} \\frac{d \\phi_{p e}}{d t}=J_{e} S_{p e}\\left(1-\\phi_{p e}\\right)-J_{i} Y_{p} \\phi_{p e} \\approx 0. \\end{equation} Here, $J_x$ and $S_x$ represent the different particle fluxes and sticking probabilities, respectively. $Y_{ie}$ is the ion-enhanced etching yield for etchant particles, $Y_p$ is the ion-enhanced etching yield on polymer, $Y_{sp}$ gives the physical ion sputtering yield, and $k_{ie}$ and $k_{ev}$ are the stoichiometric factors for ion-enhanced etching and evaporation, respectively, which are determined by the chemical etching reaction. By solving these steady state equations for the coverages, one can determine etch or deposition rates on the surface. If deposition of polymer dominates, the surface normal velocity is positive and is given by \\begin{equation} v=\\frac{1}{\\rho_{p}}\\left(J_{p} S_{p}-Y_{p} J_{i} \\phi_{p e}\\right), \\end{equation} where $\\rho_p$ is the atomic polymer density. The first term $J_{p} S_{p}$ gives the rate of polymer particles reaching and adsorbing on the surface, while the second term $Y_{p} J_{i} \\phi_{p e}$ describes the removal of polymer by ion-enhanced etching. Together, these terms describe the deposition of polymer material on the surface, which acts as passivation layer for the chemical etching process. If, on the other hand, etching of the substrate dominates, the negative surface velocity of the substrate is given by \\begin{equation} v=\\frac{1}{\\rho_{m}}\\left[J_{e v} \\phi_{e}+J_{i} Y_{ie} \\phi_{e}+J_{i} Y_{sp}\\left(1-\\phi_{e}\\right)\\right], \\end{equation} where $\\rho_m$ is the atomic density of the etched material and depends on which layer in the stack is being etched. Each term accounts for a different type of surface reaction. The first term, $J_{e v} \\phi_{e}$, describes the chemical etching process, where etchants bind chemically with the substrate to form volatile etch products which dissolve thermally from the surface. Thus, the evaporation flux $J_{ev}$ is a parameter proportional to the etchant flux $J_e$ and depends on the chemical gas and surface composition and temperature of the etching plasma. It is given by \\begin{equation} J_{ev} = K e^{-E_a/k_B T}J_e, \\end{equation} where $K$ is a process parameter describing the volatility of the chemical etching process, $E_a$ is the activation energy for thermal etching, $k_B$ is the Boltzmann constant, and $T$ is the temperature. The second term, $J_{i} Y_{ie} \\phi_{e}$, describes the contribution of ion-enhanced etching. In this surface reaction, volatile etch products which do not dissolve from the surface thermally, absorb energy from impinging ions and consequently dissolve from the surface. Finally, the last term, $J_{i} Y_{sp}\\left(1-\\phi_{e}\\right)$, describes physical sputtering of the substrate by highly energetic ions. Since both chemical and ion-enhanced etching involve etchants, they are proportional to the etchant coverage $\\phi_e$, while physical ion sputtering takes place directly on the substrate and is thus proportional to the fraction of the surface not covered by the etchant. ",
    "url": "/models/prebuilt/fluorocarbonEtching.html#fluorocarbon-etching",
    
    "relUrl": "/models/prebuilt/fluorocarbonEtching.html#fluorocarbon-etching"
  },"18": {
    "doc": "Fluorocarbon Etching",
    "title": "Ions",
    "content": "Each ion is endowed with an initial energy and direction upon creation on the source plane. The assignment of initial energies is governed by a normal distribution, characterized by a mean energy value and an energy sigma, thus allowing for stochastic variations in the initial energy states of the ions. The distribution of initial ion directions is given by a power cosine source distribution, which is defined by the exponent of the power cosine distribution. Upon impact with the surface, an energy- and angle-dependent yield is computed, which contributes to the specific surface point’s rate. The yield is expressed as: \\begin{equation} Y(E,\\theta) = A\\left(\\sqrt{E} - \\sqrt{E_{th}}\\right)f(\\theta), \\end{equation} where $E$ denotes the particle energy and $\\theta$ its incident angle. Here, $A$ represents a yield coefficient, and $E_{\\text{th}}$ denotes the material’s threshold energy for physical sputtering. The function $f(\\theta)$, which characterizes the angle-dependence of the yield. For sputtering, the function is given by: \\begin{equation} f(\\theta) = (1 + B_{sp}(1-\\cos^2(\\theta)))\\cos(\\theta), \\end{equation} while for ion-enhanced etching, the function is given by: \\begin{equation} f(\\theta) = \\cos(\\theta). \\end{equation} . The ions can also reflect from the surface. Their energy loss during reflection is described by the model proposed by Belen et al [^1]. The current ray energy is multiplied by a factor $E_\\textrm{ref}$ ($0 \\leq E_\\textrm{ref} \\leq 1$) which depends on the incoming angle $\\theta$ in the following way: \\begin{equation} E_{\\textrm{ref}}= 1-(1-A)\\frac{\\frac{\\pi}{2}-\\theta}{\\frac{\\pi}{2}-\\theta_\\textrm{inflect}} \\quad \\text{ if } \\theta \\geqslant \\theta_\\textrm{inflect} \\end{equation} \\begin{equation} E_{\\textrm{ref}}=\\mathrm{A}\\left(\\frac{\\theta}{\\theta_\\textrm{inflect}}\\right)^{n_l} \\quad \\text{ if } \\theta&lt;\\theta_\\textrm{inflect}, \\end{equation} where $A = (1 + n(\\frac{\\pi}{2 \\theta_\\textrm{inflect}} - 1))^{-1}$. Ions striking the surface at an angle denoted by $\\theta$ relative to the surface normal undergo reflection, where the angular dispersion is characterized by a cosine function centered around the direction of specular reflection defined by $\\theta_\\textrm{spec}$. This reflection process distinguishes between ions approaching the surface at glancing angles, which undergo nearly perfect specular reflection, and those striking the surface perpendicularly, which undergo nearly diffuse reflection. \\begin{equation} \\mathrm{P}(\\phi) \\propto \\cos \\left(\\frac{\\pi}{2} \\frac{\\phi}{\\frac{\\pi}{2}-\\theta_\\textrm{spec}}\\right) \\quad \\text{ if } \\theta_\\textrm{inc} \\leqslant \\theta_\\textrm{min} \\end{equation} . \\begin{equation} \\mathrm{P}(\\phi) \\propto \\cos \\left(\\frac{\\pi}{2} \\frac{\\phi}{\\frac{\\pi}{2}-\\theta_\\textrm{min}}\\right) \\quad \\text{ if } \\theta_{\\textrm{inc}}&gt;\\theta_{\\textrm{min}} \\end{equation} . The ray’s reflected direction is randomly chosen from a cone around the specular direction. The opening angle of this cone is given by the incidence angle $\\theta$. ",
    "url": "/models/prebuilt/fluorocarbonEtching.html#ions",
    
    "relUrl": "/models/prebuilt/fluorocarbonEtching.html#ions"
  },"19": {
    "doc": "Fluorocarbon Etching",
    "title": "Implementation",
    "content": "The fluorocarbon etching process is implemented in the psFluorocarbonEtching class. To customize the parameters of the process, it is advised to create a new instance of the class and set the desired parameters in the parameter struct. The following example demonstrates how to create a new instance of the class and set the parameters of the process. C++ ... auto model = psSmartPointer&lt;psFluorocarbonEtching&lt;NumericType, D&gt;&gt;::New(); auto &amp;parameters = model-&gt;getParameters(); parameters.ionFlux = 10.; parameters.Mask.rho = 500.; // this modifies a direct reference of the parameters ... Python ... model = vps.FluorocarbonEtching() parameters = model.getParameters() parameters.ionFlux = 10. parameters.Mask.rho = 500. # this modifies a direct reference of the parameters ... The strcut holds the following parameters: . | Parameter | Description | Default Value | . | ionFlux | Ion flux (1015 /cm² /s) | 56.0 | . | etchantFlux | Etchant flux (1015 /cm² /s) | 500.0 | . | polyFlux | Polymer flux (1015 /cm² /s) | 100.0 | . | etchStopDepth | Depth at which etching stops | -inf | . | temperature | Temperature (K) | 300.0 | . | k_ie | Stoichiometric factor for ion enhanced etching | 2.0 | . | k_ev | Stoichiometric factor for chemical etching | 2.0 | . | beta_p | Polymer clean surface sticking probability | 0.26 | . | beta_e | Etchant clean surface sticking probability | 0.9 | . | beta_pe | Sticking probability for etchant on polymer | 0.6 | . | delta_p | Amount of polymer need to cause deposition of the surface | 1.0 | . | Mask.rho | Mask density (1022 atoms/cm³) | 500.0 | . | Mask.beta_p | Polymer clean surface sticking probability on mask material | 0.01 | . | Mask.beta_e | Etchant clean surface sticking probability on mask material | 0.1 | . | Mask.A_sp | Mask sputtering coefficient | 0.0139 | . | Mask.B_sp | Mask yield coefficient | 9.3 | . | Mask.Eth_sp | Mask sputtering threshold energy (eV) | 20.0 | . | SiO2.rho | SiO2 density (1022 atoms/cm³) | 2.2 | . | SiO2.Eth_sp | SiO2 sputtering threshold energy (eV) | 18.0 | . | SiO2.Eth_ie | SiO2 on enhanced etching threshold energy (eV) | 4.0 | . | SiO2.A_sp | SiO2 sputtering coefficient | 0.0139 | . | SiO2.B_sp | SiO2 yield coefficient | 9.3 | . | SiO2.A_ie | SiO2 ion enhanced etching coefficient | 0.0361 | . | SiO2.K | SiO2 volatility parameter in evaporation flux | 0.002789491704544977 | . | SiO2.E_a | SiO2 activation energy (eV) | 0.168 | . | Polymer.rho | Polymer density (1022 atoms/cm³) | 2.0 | . | Polymer.Eth_ie | Polymer ion enhanced etching threshold energy (eV) | 4.0 | . | Polymer.A_ie | Polymer ion enhanced etching coefficient | 0.1444 | . | Si3N4.rho | Si3N4 density (1022 atoms/cm³) | 2.3 | . | Si3N4.Eth_sp | Si3N4 sputtering threshold energy (eV) | 18.0 | . | Si3N4.Eth_ie | Si3N4 ion enhanced etching threshold energy (eV) | 4.0 | . | Si3N4.A_sp | Si3N4 sputtering coefficient | 0.0139 | . | Si3N4.B_sp | Si3N4 yield coefficient | 9.3 | . | Si3N4.A_ie | Si3N4 ion enhanced etching coefficient | 0.0361 | . | Si3N4.K | Si3N4 volatility parameter in evaporation flux | 0.002789491704544977 | . | Si3N4.E_a | Si3N4 activation energy (eV) | 0.168 | . | Si.rho | Si density (1022 atoms/cm³) | 5.02 | . | Si.Eth_sp | Si sputtering threshold energy (eV) | 20.0 | . | Si.Eth_ie | Si ion enhanced etching threshold energy (eV) | 4.0 | . | Si.A_sp | Si sputtering coefficient | 0.0337 | . | Si.B_sp | Si yield coefficient | 9.3 | . | Si.A_ie | Si ion enhanced etching coefficient | 0.0361 | . | Si.K | Si volatility parameter in evaporation flux | 0.029997010728956663 | . | Si.E_a | Si activation energy (eV) | 0.108 | . | Ions.meanEnergy | Mean ion energy (eV) | 100.0 | . | Ions.sigmaEnergy | Standard deviation of ion energy (eV) | 10.0 | . | Ions.exponent | Exponent of power cosine source distribution of initial ion directions | 500.0 | . | Ions.inflectAngle | Inflection angle | 1.55334303 | . | Ions.n_l | Exponent of reflection power | 10.0 | . | Ions.minAngle | Minimum cone angle for ion reflection | 1.3962634 | . ",
    "url": "/models/prebuilt/fluorocarbonEtching.html#implementation",
    
    "relUrl": "/models/prebuilt/fluorocarbonEtching.html#implementation"
  },"20": {
    "doc": "Fluorocarbon Etching",
    "title": "Related Examples",
    "content": ". | Stack Etching | . ",
    "url": "/models/prebuilt/fluorocarbonEtching.html#related-examples",
    
    "relUrl": "/models/prebuilt/fluorocarbonEtching.html#related-examples"
  },"21": {
    "doc": "Fluorocarbon Etching",
    "title": "Fluorocarbon Etching",
    "content": " ",
    "url": "/models/prebuilt/fluorocarbonEtching.html",
    
    "relUrl": "/models/prebuilt/fluorocarbonEtching.html"
  },"22": {
    "doc": "Member Functions",
    "title": "psDomain Member Functions",
    "content": ". Coming soon . ",
    "url": "/domain/functions.html#psdomain-member-functions",
    
    "relUrl": "/domain/functions.html#psdomain-member-functions"
  },"23": {
    "doc": "Member Functions",
    "title": "Constructors",
    "content": "psDomain() psDomain(psSmartPointer&lt;psDomain&gt; passedDomain) psDomain(lsDomainType passedLevelSet, bool generateCellSet = false, const NumericType passedCellSetDepth = 0., const bool passedCellSetPosition = false) psDomain(lsDomainsType passedLevelSets, bool generateCellSet = false, const NumericType passedCellSetDepth = 0., const bool passedCellSetPosition = false) . ",
    "url": "/domain/functions.html#constructors",
    
    "relUrl": "/domain/functions.html#constructors"
  },"24": {
    "doc": "Member Functions",
    "title": "Member Functions",
    "content": "void deepCopy(psSmartPointer&lt;psDomain&gt; passedDomain) void insertNextLevelSet(lsDomainType passedLevelSet, bool wrapLowerLevelSet = true) void insertNextLevelSetAsMaterial(lsDomainType passedLevelSet, const psMaterial material, bool wrapLowerLevelSet = true) void duplicateTopLevelSet(const psMaterial material = psMaterial::None) void removeTopLevelSet() void applyBooleanOperation(lsDomainType levelSet, lsBooleanOperationEnum operation) void generateCellSet(const NumericType depth = 0., const bool passedCellSetPosition = false) void setMaterial(unsigned int lsId, const psMaterial material) auto &amp;getLevelSets() const auto &amp;getMaterialMap() const auto &amp;getCellSet() const auto &amp;getGrid() const void print() const void saveLevelSetMesh(std::string name, int width = 1) void saveSurfaceMesh(std::string name, bool addMaterialIds = true) void saveVolumeMesh(std::string name) void saveLevelSets(std::string fileName) const void clear() . ",
    "url": "/domain/functions.html",
    
    "relUrl": "/domain/functions.html"
  },"25": {
    "doc": "GDS File Import",
    "title": "Importing a GDSII Mask File",
    "content": ". ViennaPS provides a convenient feature allowing users to import geometries directly from GDSII mask files. It’s important to note that ViennaPS focuses on handling simple geometry information extracted from GDSII files, without supporting additional data that might be stored within the GDSII format. To parse a GDSII file using ViennaPS, follow these steps: . | Create a psGDSGeometry Object: Initialize a psGDSGeometry object, specifying the desired grid spacing, boundary conditions, and additional padding (optional). auto mask = psSmartPointer&lt;psGDSGeometry&lt;NumericType, D&gt;&gt;::New(); mask-&gt;setGridDelta(gridDelta); mask-&gt;setBoundaryConditions(boundaryConds); mask-&gt;setBoundaryPadding(xPad, yPad); . Replace gridDelta, boundaryConds, and xPad,yPad with your preferred values. The geometry is always parsed on a plane normal to the z direction. The values of xPad and yPad are always added to the largest and subtracted from the smallest extension of all geometries in the GDSII file. | Use psGDSReader to Parse Geometry: Utilize the psGDSReader to parse the GDSII file into the previously created psGDSGeometry object. psGDSReader&lt;NumericType, D&gt;(mask, \"path/to/your/file.gds\").apply(); . Replace \"path/to/your/file.gds\" with the actual path to your GDSII file. | Convert Single Layers to Level Sets: Extract specific layers from the parsed GDSII geometry, convert them into level sets, and add them to your simulation domain. To access a particular layer, provide its GDSII layer number. // Create new domain auto domain = psSmartPointer&lt;psDomain&lt;NumericType, D&gt;&gt;::New(); // Convert the layer to a level set and add it to the domain. auto layer = mask-&gt;layerToLevelSet(0 /*layer*/, 0 /*base z position*/, 0.5 /*height*/); domain-&gt;insertNextLevelSet(layer); . Replace layerNumber with the GDSII layer number you wish to access. Layers can also be inverted to be used a mask. // Create new domain auto domain = psSmartPointer&lt;psDomain&lt;NumericType, D&gt;&gt;::New(); // Convert the inverted layer to a level set and add it to the domain. auto layer = mask-&gt;layerToLevelSet(0 /*layer*/, 0 /*base z position*/, 0.5 /*height*/, true /*invert*/); domain-&gt;insertNextLevelSetAsMaterial(layer, psMaterial::Mask); // Create substrate underneath the mask psMakePlane&lt;NumericType, D&gt;(domain, 0. /*base z position*/, psMaterial::Si).apply(); . | . ",
    "url": "/geo/gdsimport.html#importing-a-gdsii-mask-file",
    
    "relUrl": "/geo/gdsimport.html#importing-a-gdsii-mask-file"
  },"26": {
    "doc": "GDS File Import",
    "title": "Related Examples",
    "content": ". | GDS Reader | . ",
    "url": "/geo/gdsimport.html#related-examples",
    
    "relUrl": "/geo/gdsimport.html#related-examples"
  },"27": {
    "doc": "GDS File Import",
    "title": "GDS File Import",
    "content": " ",
    "url": "/geo/gdsimport.html",
    
    "relUrl": "/geo/gdsimport.html"
  },"28": {
    "doc": "Hole Geometry",
    "title": "Hole Geometry",
    "content": "#include &lt;psMakeHole.hpp&gt; . The psMakeHole class generates a hole geometry in the z direction, which, in 2D mode, corresponds to a trench geometry. Positioned at the origin, the hole is centered, with the total extent defined in the x and y directions. The normal direction for the hole creation is in the positive z direction in 3D and the positive y direction in 2D. Users can specify the hole’s radius, depth, and opt for tapering with a designated angle. The hole configuration may include periodic boundaries in both the x and y directions. Additionally, the hole can serve as a mask, with the specified material only applied to the bottom of the hole, while the remainder adopts the mask material. psMakeHole(psDomainType domain, const NumericType gridDelta, const NumericType xExtent, const NumericType yExtent, const NumericType holeRadius, const NumericType holeDepth, const NumericType taperAngle = 0., // in degrees const NumericType baseHeight = 0., const bool periodicBoundary = false, const bool makeMask = false, const psMaterial material = psMaterial::None) . | Parameter | Description | Type | . | domain | Specifies the type of domain for the hole geometry. | psSmartPointer&lt;psDomain&lt;NumericType, D&gt;&gt; | . | gridDelta | Represents the grid spacing or resolution used in the simulation. | NumericType | . | xExtent | Defines the extent of the hole geometry in the x-direction. | NumericType | . | yExtent | Specifies the extent of the hole geometry in the y-direction. | NumericType | . | holeRadius | Sets the radius of the hole. | NumericType | . | holeDepth | Determines the depth of the hole. | NumericType | . | taperAngle | (Optional) Specifies the angle of tapering for the hole geometry in degrees. Default is set to 0. | NumericType | . | baseHeight | (Optional) Sets the base height of the hole. Default is set to 0. | NumericType | . | periodicBoundary | (Optional) If set to true, enables periodic boundaries in both x and y directions. Default is set to false. | bool | . | makeMask | (Optional) If set to true, allows the hole to function as a mask, with specified material applied only to the bottom. Default is set to false. | bool | . | material | (Optional) Specifies the material used for the hole. Default is set to psMaterial::None. | psMaterial | . Example usage: . C++ . auto domain = psSmartPointer&lt;psDomain&lt;NumericType, D&gt;&gt;::New(); psMakeHole&lt;NumericType, D&gt;(domain, 0.5, 10.0, 10.0, 2.5, 5.0, 10., 0., false, false, psMaterial::Si) .apply(); . Python . domain = vps.Domain() vps.MakeHole(domain=domain, gridDelta=0.5, xExtent=10.0, yExtent=10.0, holeRadius=2.5, holeDepth=5.0, taperingAngle=10.0, baseHeight=0.0, periodicBoundary=False, makeMask=False, material=vps.Material.Si, ).apply() . ",
    "url": "/geo/basic/hole.html",
    
    "relUrl": "/geo/basic/hole.html"
  },"29": {
    "doc": "General Notes",
    "title": "General Notes",
    "content": ". ",
    "url": "/general/",
    
    "relUrl": "/general/"
  },"30": {
    "doc": "General Notes",
    "title": "Numeric Types",
    "content": "ViennaPS supports the utilization of either float or double as the underlying numeric type. While float might offer slightly higher performance in some cases, it is generally recommended to use double in your simulation due to its enhanced precision. It’s essential to note that the choice of numeric type is a static (compile-time) parameter in every ViennaPS class and function. Once a numeric type is selected for a particular simulation, it is not possible to switch to a different numeric type within the program. Additionally, for users working with Python bindings, it’s important to be aware that the Python interface always uses double as the numeric type. ",
    "url": "/general/#numeric-types",
    
    "relUrl": "/general/#numeric-types"
  },"31": {
    "doc": "General Notes",
    "title": "Switching between 2D and 3D mode",
    "content": "ViennaPS provides the flexibility for users to choose between 2D and 3D modes during compile time. The dimensionality is specified as a second template (static) parameter, and most classes and functions in ViennaPS adhere to this structure. It’s important to note that 2D and 3D classes cannot be mixed within the same simulation, and the choice of dimensionality is fixed at compile time. For users who need to transition from a 2D to a 3D simulation, ViennaPS offers the psExtrude utility. This utility enables the extrusion of a 2D domain to 3D, providing a seamless way to extend simulations across different dimensions. ",
    "url": "/general/#switching-between-2d-and-3d-mode",
    
    "relUrl": "/general/#switching-between-2d-and-3d-mode"
  },"32": {
    "doc": "General Notes",
    "title": "Using Smart Pointers",
    "content": "In ViennaPS, smart pointers are utilized to pass domains, models, and other essential objects to processes and utility functions. To facilitate this, the library includes a custom class named psSmartPointer, serving as a shared pointer implementation. This design choice ensures efficient memory management and enables seamless interaction between different components within the simulation framework. Example: . // Creating a new domain auto domain = psSmartPointer&lt;psDomain&lt;NumericType, D&gt;&gt;::New(); // Using a pre-built model auto model = psSmartPointer&lt;psIsotropicProcess&lt;NumericType, D&gt;&gt;::New(/*pass constructor arguments*/); . ",
    "url": "/general/#using-smart-pointers",
    
    "relUrl": "/general/#using-smart-pointers"
  },"33": {
    "doc": "Dependencies",
    "title": "Dependencies",
    "content": ". ",
    "url": "/deps/",
    
    "relUrl": "/deps/"
  },"34": {
    "doc": "Dependencies",
    "title": "ViennaLS",
    "content": "ViennaLS forms the foundation of the process simulator, applying the level-set surface representation concepts for topography simulations. This module not only stores the level-set surface but also encompasses essential algorithms for geometry initialization, level-set value manipulation based on a velocity field, surface feature analysis, and seamless conversion of the level-set representation to other commonly employed material representations in device simulators. ",
    "url": "/deps/#viennals",
    
    "relUrl": "/deps/#viennals"
  },"35": {
    "doc": "Dependencies",
    "title": "ViennaRay",
    "content": "ViennaPS relies on ViennaRay, a top-down Monte Carlo flux calculation library, to carry out essential flux calculations. This library is built upon Intel®’s ray tracing kernel, Embree. Crafted with a focus on efficiency and high-performance ray tracing, ViennaRay ensures a seamless user experience through its straightforward and user-friendly interface. In the top-down Monte Carlo approach, a large number of pseudo-particles are launched from a source plane situated above the surface, and their points of impact on the surface are determined. These pseudo-particles are initialized with a uniform initial position on the source plane and an initial direction that follows a power-cosine distribution. Each pseudo-particle carries a specific payload, representing a fraction of the total source flux. Upon reaching the surface, the current payload of the pseudo-particle contributes to the flux at that particular surface location. Furthermore, pseudo-particles have the capability to undergo reflection from the surface. The payload of a pseudo-particle undergoes reduction by the sticking coefficient during reflection. As a result, a pseudo-particle is tracked until its payload falls below a certain threshold or until it exits the simulation domain. This tracking mechanism provides a comprehensive understanding of the particle dynamics during its interaction with the sample surface. ",
    "url": "/deps/#viennaray",
    
    "relUrl": "/deps/#viennaray"
  },"36": {
    "doc": "Miscellaneous",
    "title": "Miscellaneous",
    "content": " ",
    "url": "/misc/",
    
    "relUrl": "/misc/"
  },"37": {
    "doc": "Geometry Output",
    "title": "Geometry Output",
    "content": ". ViennaPS provides various methods for outputting the surface or volume of the processed domain. The data is typically saved in the VTK file format, with surfaces stored in .vtp files and volumes in .vtu files. For visualization, we recommend using ParaView, a powerful open-source visualization tool. Below, you’ll find further details on the available geometry outputs. In addition to VTK file formats, ViennaPS provides the flexibility to store level sets directly in the proprietary .lvst format. This feature enables users to save intermediate states during the process, allowing for more detailed analysis and the ability to revisit specific simulation stages. ",
    "url": "/output/",
    
    "relUrl": "/output/"
  },"38": {
    "doc": "Advanced Cell-Set Functionalities",
    "title": "Advanced Cell-Set Functionalities",
    "content": ". Coming soon . ",
    "url": "/cellset/",
    
    "relUrl": "/cellset/"
  },"39": {
    "doc": "Installing the Library",
    "title": "Installing the Library",
    "content": ". ",
    "url": "/inst/",
    
    "relUrl": "/inst/"
  },"40": {
    "doc": "Installing the Library",
    "title": "Supported Operating Systems",
    "content": ". | Windows (Visual Studio) . | Linux (g++ / clang) . | macOS (XCode) . | . ",
    "url": "/inst/#supported-operating-systems",
    
    "relUrl": "/inst/#supported-operating-systems"
  },"41": {
    "doc": "Installing the Library",
    "title": "System Requirements",
    "content": ". | C++17 Compiler with OpenMP support | . ",
    "url": "/inst/#system-requirements",
    
    "relUrl": "/inst/#system-requirements"
  },"42": {
    "doc": "Installing the Library",
    "title": "Installation",
    "content": "Since this is a header only project, it does not require any installation. However, we recommend the following procedure in order to set up all dependencies correctly and relocate all header files to a designated directory: . git clone https://github.com/ViennaTools/ViennaPS.git cd ViennaPS mkdir build &amp;&amp; cd build cmake .. -DCMAKE_INSTALL_PREFIX=/path/to/your/custom/install/ make buildDependencies # this will install all dependencies and might take a while make install . The CMake configuration automatically checks if the dependencies are installed. If CMake is unable to find them, the dependencies will be built from source with the buildDependencies target. This will install the necessary headers and CMake files to the specified path. If CMAKE_INSTALL_PREFIX is not specified, it will be installed to the standard path for your system, usually /usr/local/ . If one wants to use a specific installation of one or more of the dependencies, just pass the corresponding *_DIR variable as a configuration option (e.g. -DViennaLS_DIR=/path/to/viennals/install -DViennaRay_DIR=/path/to/viennaray/install). ViennaLS and ViennaRay both have external dependencies which can be installed beforehand to save some time when building the dependencies. ViennaLS uses VTK as dependency and ViennaRay uses Embree. On Linux based systems, these dependencies can be installed using the package manager: sudo apt install libvtk9.1 libvtk9-dev libembree3-3 libembree-dev. On macOS, one can use Homebrew to install these dependencies: brew install vtk embree. ",
    "url": "/inst/#installation",
    
    "relUrl": "/inst/#installation"
  },"43": {
    "doc": "Installing the Library",
    "title": "Building the Python package",
    "content": "In order to build the Python bindings, the pybind11 library is required. On Linux based system (Ubuntu/Debian), pybind11 can be installed via the package manager: sudo apt install pybind11-dev. For macOS, the installation via Homebrew is recommended: brew install pybind11. The ViennaPS Python package can be built and installed using the pip command: . git clone https://github.com/ViennaTools/ViennaPS.git cd ViennaPS pip install --user . Some functionalities of the ViennaPS Python module only work in combination with the ViennaLS Python module. It is therefore recommended to additionally install the ViennaLS Python module on your system. Instructions to do so can be found in the ViennaLS Git Repository. ",
    "url": "/inst/#building-the-python-package",
    
    "relUrl": "/inst/#building-the-python-package"
  },"44": {
    "doc": "Installing the Library",
    "title": "Using the Python package",
    "content": "The 2D version of the library can be imported as follows: . import viennaps2d as vps . In order to switch to three dimensions, only the import needs to be changed: . import viennaps3d as vps . ",
    "url": "/inst/#using-the-python-package",
    
    "relUrl": "/inst/#using-the-python-package"
  },"45": {
    "doc": "Installing the Library",
    "title": "Integration in CMake projects",
    "content": "In order to use this library in your CMake project, add the following lines to the CMakeLists.txt of your project: . set(ViennaPS_DIR \"/path/to/your/custom/install/\") find_package(ViennaPS REQUIRED) add_executable(${PROJECT_NAME} ...) target_include_directories(${PROJECT_NAME} PUBLIC ${VIENNAPS_INCLUDE_DIRS}) target_link_libraries(${PROJECT_NAME} ${VIENNAPS_LIBRARIES}) . ",
    "url": "/inst/#integration-in-cmake-projects",
    
    "relUrl": "/inst/#integration-in-cmake-projects"
  },"46": {
    "doc": "Pre-Built Models",
    "title": "Pre-Built Models",
    "content": " ",
    "url": "/models/prebuilt/",
    
    "relUrl": "/models/prebuilt/"
  },"47": {
    "doc": "Custom Models",
    "title": "Custom Models",
    "content": ". Users can create a custom process model by interfacing one or more of the classes described below and then inserting them into their custom process model. | The psSurfaceModel class is used to describe surface reactions, combining particle fluxes with the surface chemical reactions. | The psVelocityField provides the interface between surface velocities and the advection kernel to integrate the Level-Set equation in a time step. | ViennaPS seamlessly integrates ViennaRay functionality through the rayParticle class, providing users with a versatile interface to define the key characteristics of the simulated particle species. | . ",
    "url": "/models/custom/",
    
    "relUrl": "/models/custom/"
  },"48": {
    "doc": "Process Models",
    "title": "Process Models",
    "content": "#include &lt;psProcessModel.hpp&gt; . All the information about the process is encompassed in the class psProcessModel, as it includes all the particle type information required for ray tracing, the surface model, as well as advection callbacks, for generating volume models describing chemical processes inside the material. Users have the flexibility to configure their own custom process model or opt for pre-defined models encompassing frequently used processes. ",
    "url": "/models/",
    
    "relUrl": "/models/"
  },"49": {
    "doc": "Running a Process",
    "title": "Running a Process",
    "content": "#include &lt;psProcess.hpp&gt; . The psProcess class functions as the primary simulation interface, consolidating crucial elements such as the simulation domain, process model, process duration, and requisite ray-tracing parameters. This interface also encompasses the necessary methods for configuring these attributes. Upon setting these parameters, the apply() method is employed to execute the process, initiating and conducting the simulation. Example usage: . C++ ... psProcess&lt;NumericType, D&gt; process; process.setDomain(myDomain); process.setProcessModel(myModel); process.setProcessDuration(10.); process.setNumberOfRaysPerPoint(1000); process.enableFluxSmoothing(); process.apply(); ... Python ... process = vps.Process() process.setDomain(myDomain) process.setProcessModel(myModel) process.setProcessDuration(10.) process.setNumberOfRaysPerPoint(1000) process.enableFluxSmoothing() process.apply() ... ",
    "url": "/process/",
    
    "relUrl": "/process/"
  },"50": {
    "doc": "Running a Process",
    "title": "Member Functions",
    "content": "Constructors . // Default constructor psProcess() // Constructor from domain psProcess(psSmartPointer&lt;psDomain&lt;NumericType, D&gt;&gt; passedDomain) // Constructor from domain, process model, and duration, // to apply simple processes template &lt;typename ProcessModelType&gt; psProcess(psSmartPointer&lt;psDomain&lt;NumericType, D&gt;&gt; passedDomain, psSmartPointer&lt;ProcessModelType&gt; passedProcessModel, const NumericType passedDuration = 0.) . In summary, these constructors provide different ways to create a psProcess object, allowing for flexibility depending on what data is available at the time of object creation. | The first constructor is a default constructor. It’s defined as psProcess() and it doesn’t take any arguments. This constructor allows for the creation of a psProcess object without any initial values. | The second constructor takes a single argument: a smart pointer to a psDomain object. This constructor initializes the domain member variable of the psProcess class with the passed psDomain object. | The third constructor is a template constructor that takes three arguments: a smart pointer to a psDomain object, a smart pointer to a ProcessModelType object, and a NumericType representing the process duration. This constructor initializes the domain and processDuration member variables with the passed values and also sets the model member variable to the dynamically cast ProcessModelType object. This allows the user to run a process from an anonymous object. For example: psProcess&lt;NumericType, D&gt;(myDomain, myModel, processDuration).apply() . | . Set the domain . void setDomain(psSmartPointer&lt;psDomain&lt;NumericType, D&gt;&gt; passedDomain) . Sets the process domain. Set the process model . template &lt;typename ProcessModelType&gt; void setProcessModel(psSmartPointer&lt;ProcessModelType&gt; passedProcessModel) . Sets the process model. This can be either a pre-configured process model or a custom process model. A custom process model must interface the psProcessModel class. Set the source direction . void setSourceDirection(const rayTraceDirection passedDirection) . Set the source direction, where the rays should be traced from. The passed direction parameter is using the enum rayTraceDirection which contains the following values: POS_X, NEG_X, POS_Y, NEG_Y, POS_Z, NEG_Z. Set the process duration . void setProcessDuration(NumericType passedDuration) . Specifies the duration of the process. If the process duration is set to 0, exclusively the advection callback applyPreAdvect() is executed on the domain. This feature is particularly useful for applying only a volume model without engaging in further simulation steps. Set the number of rays to be traced . void setNumberOfRaysPerPoint(unsigned raysPerPoint) . Specify the number of rays to be traced for each particle throughout the process. The total count of rays is the product of this number and the number of points in the process geometry. Set the number of coverage initialization iterations . void setMaxCoverageInitIterations(unsigned numIter) . Set the number of iterations to initialize the coverages. Enable or disable flux smoothing . void enableFluxSmoothing() void disableFluxSmoothing() . Toggle the option to enable or disable flux smoothing. When flux smoothing is activated, the flux at each surface point, computed by the ray tracer, undergoes averaging across the neighboring surface points. Per default, flux smoothing is enabled. Set the integration scheme . void setIntegrationScheme(lsIntegrationSchemeEnum passedIntegrationScheme) . Set the integration scheme for solving the level-set equation. Possible integration schemes are specified in lsIntegrationSchemeEnum. Set the time step ratio . void setTimeStepRatio(NumericType cfl) . Set the CFL (Courant-Friedrichs-Levy) condition to use during surface advection in the level-set. The CFL condition defines the maximum distance a surface is allowed to move in a single advection step. It MUST be below 0.5 to guarantee numerical stability. Defaults to 0.4999. Set time interval to save intermediate results . void setPrintTimeInterval(NumericType passedTime) . Sets the minimum time between printing intermediate results during the process. If this is set to a non-positive value, no intermediate results are printed. ",
    "url": "/process/#member-functions",
    
    "relUrl": "/process/#member-functions"
  },"51": {
    "doc": "Simulation Domain",
    "title": "Simulation Domain",
    "content": "#include &lt;psDomain.hpp&gt; . In our simulation framework, the essential hub for all geometry details is the psDomain class. This class is like a smart keeper of information, holding everything about the materials in the simulation domain. It uses level sets to show surfaces and material interfaces with great detail and organizes data in a cell-based structure for the underlying volumes. Depending on the specific process, it can use one or both of these methods. This flexibility ensures that the simulation can handle different processes accurately and efficiently. ",
    "url": "/domain/",
    
    "relUrl": "/domain/"
  },"52": {
    "doc": "Basic Geometries",
    "title": "Basic Geometries",
    "content": ". ViennaPS provides a set of functions to effortlessly create basic geometries, facilitating quick testing of models or serving as the groundwork for your process simulation configuration. The various available geometries are outlined below: . ",
    "url": "/geo/basic/",
    
    "relUrl": "/geo/basic/"
  },"53": {
    "doc": "Creating a Geometry",
    "title": "Creating a Geometry",
    "content": ". Create intricate geometries using the versatile tools offered by ViennaLS or generate a basic geometry using of the provided geometry builders. Alternatively, you can import a geometry from a GDSII mask file. ",
    "url": "/geo/",
    
    "relUrl": "/geo/"
  },"54": {
    "doc": "Examples",
    "title": "Examples",
    "content": ". | Custom Example Process | GDS Reader | Cantilever Wet Etching | Selective Epitaxy | Trench Deposition | Trench Deposition Geometric | TEOS Trench Deposition | Hole Etching | Stack Etching | Oxide Regrowth | Volume Model | KD Tree Benchmark | Interpolation Demo | . ",
    "url": "/examples/",
    
    "relUrl": "/examples/"
  },"55": {
    "doc": "Home",
    "title": "ViennaPS",
    "content": "Process Simulation Library . Get started now View it on GitHub . ViennaPS is a header-only C++ process simulation library, which includes surface and volume representations, a ray tracer, and physical models for the simulation of microelectronic fabrication processes. This library seamlessly integrates advanced level-set functionalities with top-down Monte Carlo flux calculations, powered by state-of-the-art ray tracing techniques. This combination brings a new level of accuracy and efficiency to process simulations, empowering engineers and researchers to model complex systems. ViennaPS is under heavy development and improved daily. If you do have suggestions or find bugs, please let us know on GitHub or contact us directly at viennatools@iue.tuwien.ac.at! . This documentation serves as your comprehensive guide to understanding, implementing, and harnessing the capabilities of our process simulation library. Whether you are a seasoned researcher seeking to refine your simulations or an engineer aiming to optimize real-world processes, this library provides a versatile and robust platform to meet your diverse needs. Throughout this documentation, you will find detailed explanations, practical examples, and best practices to effectively utilize the library. We aim to empower users with the knowledge and tools necessary to simulate a wide range of processes accurately and efficiently, making informed decisions and driving innovation in the field. ",
    "url": "/#viennaps",
    
    "relUrl": "/#viennaps"
  },"56": {
    "doc": "Home",
    "title": "About the project",
    "content": "ViennaPS was developed under the aegis of the Institute for Microelectronics at the TU Wien. Current contributors: Tobias Reiter, Julius Piso . Contact us via: viennatools@iue.tuwien.ac.at . Contributing . If you want to contribute to ViennaPS, make sure to follow the LLVM Coding guidelines. Before creating a pull request, make sure ALL files have been formatted by clang-format, which can be done using the format-project.sh script in the root directory. License . See file LICENSE in the base directory. ",
    "url": "/#about-the-project",
    
    "relUrl": "/#about-the-project"
  },"57": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"58": {
    "doc": "Isotropic Process",
    "title": "Isotropic Process",
    "content": "#include &lt;psIsotropicProcess.hpp&gt; . An isotropic etching or deposition process initiates across all materials in the domain, excluding the masking material, which is by default set to psMaterial::None. The default setting means, that the process unfolds uniformly across all materials within the domain. When the rate is less than 0, the material undergoes etching. Conversely, when the rate exceeds 0, material deposition occurs in accordance with the material of the top level set. If you want to deposit a new material, make sure to call the function duplicateTopLevelSet in your domain instance. psIsotropicProcess(const NumericType rate, const psMaterial maskMaterial = psMaterial::None) . | Parameter | Description | Type | . | rate | Rate of the process. | NumericType | . | maskMaterial | Material that does not participate in the process. | psMaterial | . Deposition example: . C++ . #include &lt;psIsotropicProcess.hpp&gt; #include &lt;psMakeTrench.hpp&gt; #include &lt;psProcess.hpp&gt; int main() { using NumericType = double; constexpr int D = 2; auto domain = psSmartPointer&lt;psDomain&lt;NumericType, D&gt;&gt;::New(); psMakeTrench&lt;NumericType, D&gt;(domain, 0.1 /*gridDelta*/, 20. /*xExtent*/, 20. /*yExtent*/, 10. /*trenchWidth*/, 10. /*trenchDepth*/, 0., 0., false, false, psMaterial::Si) .apply(); // duplicate top layer to capture deposition domain-&gt;duplicateTopLevelSet(psMaterial::SiO2); auto model = psSmartPointer&lt;psIsotropicProcess&lt;NumericType, D&gt;&gt;::New( 0.1 /*rate*/, psMaterial::None); domain-&gt;saveVolumeMesh(\"trench_initial\"); psProcess&lt;NumericType, D&gt;(domain, model, 20.).apply(); // run process for 20s domain-&gt;saveVolumeMesh(\"trench_final\"); } . Python . import viennaps2d as vps domain = vps.Domain() vps.MakeTrench(domain=domain, gridDelta=0.1, xExtent=20.0, yExtent=20.0, trenchWidth=10.0, trenchDepth=10.0, taperingAngle=0.0, baseHeight=0.0, periodicBoundary=False, makeMask=False, material=vps.Material.Si ).apply() # duplicate top layer to capture deposition domain.duplicateTopLevelSet(vps.Material.SiO2) model = vps.IsotropicProcess(rate=0.1) domain.saveVolumeMesh(\"trench_initial\") vps.Process(domain, model, 20.0).apply() domain.saveVolumeMesh(\"trench_final\") . Results: . Etching example: . C++ . #include &lt;psIsotropicProcess.hpp&gt; #include &lt;psMakeTrench.hpp&gt; #include &lt;psProcess.hpp&gt; int main() { using NumericType = double; constexpr int D = 2; auto domain = psSmartPointer&lt;psDomain&lt;NumericType, D&gt;&gt;::New(); psMakeTrench&lt;NumericType, D&gt;(domain, 0.1 /*gridDelta*/, 20. /*xExtent*/, 20. /*yExtent*/, 5. /*trenchWidth*/, 5. /*trenchDepth*/, 0., 0., false, true /*makeMask*/, psMaterial::Si) .apply(); auto model = psSmartPointer&lt;psIsotropicProcess&lt;NumericType, D&gt;&gt;::New( -0.1 /*rate*/, psMaterial::Mask); domain-&gt;saveVolumeMesh(\"trench_initial\"); psProcess&lt;NumericType, D&gt;(domain, model, 50.).apply(); // run process for 20s domain-&gt;saveVolumeMesh(\"trench_final\"); } . Python . import viennaps2d as vps domain = vps.Domain() vps.MakeTrench(domain=domain, gridDelta=0.1, xExtent=20.0, yExtent=20.0, trenchWidth=5.0, trenchDepth=5.0, taperingAngle=0.0, baseHeight=0.0, periodicBoundary=False, makeMask=True, material=vps.Material.Si ).apply() model = vps.IsotropicProcess(rate=-0.1, maskMaterial=vps.Material.Mask) domain.saveVolumeMesh(\"trench_initial\", True) vps.Process(domain, model, 50.0).apply() domain.saveVolumeMesh(\"trench_final\", True) . ",
    "url": "/models/prebuilt/isotropic.html",
    
    "relUrl": "/models/prebuilt/isotropic.html"
  },"59": {
    "doc": "Level Set",
    "title": "Level Set",
    "content": ". ",
    "url": "/output/levelset.html",
    
    "relUrl": "/output/levelset.html"
  },"60": {
    "doc": "Level Set",
    "title": "Saving the Domain",
    "content": "Documentation Coming soon . ",
    "url": "/output/levelset.html#saving-the-domain",
    
    "relUrl": "/output/levelset.html#saving-the-domain"
  },"61": {
    "doc": "Level Set",
    "title": "Visualization",
    "content": "ViennaPS provides a feature enabling users to save the level set grid points explicitly for each material layer within the domain in the VTK file format. This export includes the level set value associated with each grid point. Users also have the option to specify a width parameter, determining the number of grid points around the zero level set. This functionality enhances the ability to analyze and visualize the level set information in a detailed and customizable manner. Example usage: . C++ . auto domain = psSmartPointer&lt;psDomain&lt;NumericType, D&gt;&gt;::New(); ... // create geometry in domain ... domain-&gt;saveLevelSetMesh(\"fileNamePrefix\", 3 /* width */); . Python: . domain = vps.Domain() ... # create geometry in domain ... domain.saveLevelSetMesh(fileName=\"fileNamePrefix\", width=3) . ",
    "url": "/output/levelset.html#visualization",
    
    "relUrl": "/output/levelset.html#visualization"
  },"62": {
    "doc": "Logging",
    "title": "Logging",
    "content": ". Singleton class for thread-safe logging. The psLogger class can be used to set the verbosity of the program. The verbosity levels are: . | Code | Description | . | ERROR | Log errors only | . | WARNING | Log warnings | . | INFO | Log information (e.g. remaining time) | . | TIMING | Log timing results for the different methods | . | INTERMEDIATE | Save intermediate results (disk meshes) during the process | . | DEBUG | Debug | . Example usage: Set the log level of the current program to INTERMEDIATE . C++ . psLogger::setLogLevel(psLogLevel::INTERMEDIATE); . Python . vps.Logger.setLogLevel(vps.LogLevel.INTERMEDIATE) . ",
    "url": "/misc/logging.html",
    
    "relUrl": "/misc/logging.html"
  },"63": {
    "doc": "Material Mapping",
    "title": "Material Mapping",
    "content": ". If specified, each Level-Set in the psDomain is assigned a specific material, which can be used in a process to implement material-specific rates or similar. The following materials are available: Mask, Si, SiO2, Si3N4, SiN, SiON, SiC, SiGe, PolySi, GaN, W, Al2O3, TiN, Cu, Polymer, Dielectric, Metal, Air, GAS. ",
    "url": "/domain/material.html",
    
    "relUrl": "/domain/material.html"
  },"64": {
    "doc": "Oxide Regrowth",
    "title": "Oxide Regrowth",
    "content": "#include &lt;psOxideRegrowth.hpp&gt; . Coming soon . ",
    "url": "/models/prebuilt/oxideRegrowth.html#oxide-regrowth",
    
    "relUrl": "/models/prebuilt/oxideRegrowth.html#oxide-regrowth"
  },"65": {
    "doc": "Oxide Regrowth",
    "title": "Related Examples",
    "content": ". | Oxide Regrowth | . ",
    "url": "/models/prebuilt/oxideRegrowth.html#related-examples",
    
    "relUrl": "/models/prebuilt/oxideRegrowth.html#related-examples"
  },"66": {
    "doc": "Oxide Regrowth",
    "title": "Oxide Regrowth",
    "content": " ",
    "url": "/models/prebuilt/oxideRegrowth.html",
    
    "relUrl": "/models/prebuilt/oxideRegrowth.html"
  },"67": {
    "doc": "Parsing Parameters",
    "title": "Parsing Parameters",
    "content": ". Coming soon . ",
    "url": "/misc/parsing.html",
    
    "relUrl": "/misc/parsing.html"
  },"68": {
    "doc": "Particles - Flux Calculation",
    "title": "Particles - Flux Calculation",
    "content": ". ViennaPS integrates advanced ray tracing techniques, leveraging the power of the ViennaRay library based on Intel®’s Embree ray tracing kernel, into the realm of process simulations. This combination enables precise and efficient flux calculations within topography simulations. This process includes launching rays from a source and tracing their paths as they interact with the surface geometry. Ray tracing allows for the simulation of complex phenomena such as shadows, reflections, and transmission of energy through transparent materials. ViennaPS seamlessly integrates ViennaRay functionality through the rayParticle class, providing users with a versatile interface to define the key characteristics of the simulated particle species and tailor their behavior upon surface interactions, including reflective properties. Within the particle class, users can fine-tune parameters governing the initial state of particles, enabling precise control over their interactions with material surfaces. For an in-depth understanding of the rayParticle class and its functionalities, users are encouraged to refer to the detailed documentation available within the ViennaRay documentation. Within ViennaPS, a process model has the flexibility to encompass multiple particle species, each contributing distinct characteristics to the simulation. The fluxes computed from these particles are conveniently accessible through the psSurfaceModel class. This crucial interface allows users to seamlessly integrate the particle flux data into a physical model, facilitating the simulation of intricate physical processes. By leveraging the calculated fluxes within the surface model, users can construct comprehensive simulations that capture the nuanced interplay of particles and materials, offering a robust framework for exploring diverse scenarios in process simulation. ",
    "url": "/models/custom/particle.html",
    
    "relUrl": "/models/custom/particle.html"
  },"69": {
    "doc": "Planarize Geometry",
    "title": "Planarize a Geometry",
    "content": "#include &lt;psPlanarize.hpp&gt; . With this class, the user is able to planarize the domain at a specified cutoff position. The planarization process involves subtracting a plane from all materials within the domain using a boolean operation. Example usage: . C++ . psPlanarize&lt;double, 3&gt;(domain, 0. /*cut off height in z-direction*/).apply(); . Python . vps.Planarize(geometry=domain, cutoffHeight=0.).apply() . ",
    "url": "/misc/planarize.html#planarize-a-geometry",
    
    "relUrl": "/misc/planarize.html#planarize-a-geometry"
  },"70": {
    "doc": "Planarize Geometry",
    "title": "Planarize Geometry",
    "content": " ",
    "url": "/misc/planarize.html",
    
    "relUrl": "/misc/planarize.html"
  },"71": {
    "doc": "Plane Geometry",
    "title": "Plane Geometry",
    "content": "#include &lt;psMakePlane.hpp&gt; . The psMakePlane class offers a straightforward approach to generate a plane as a level-set within your domain. This utility is useful for crafting substrates with any material. You have the flexibility to append the plane to an existing geometry or create a new one. In 3D, the plane is generated with a normal direction in the positive z direction, while in 2D, it is oriented in the positive y direction. The plane is centered around the origin, with the total specified extent and height. Additionally, you can opt for a periodic boundary in the x and y directions. // New geometry psMakePlane(psDomainType domain, const NumericType gridDelta, const NumericType xExtent, const NumericType yExtent, const NumericType height, const bool periodicBoundary = false, const psMaterial material = psMaterial::None) // Add to existing geometry psMakePlane(psDomainType domain, NumericType height = 0., const psMaterial material = psMaterial::None) . Depending on the specific constructor invoked for the plane-builder, the behavior varies: the domain may be cleared, and a new plane inserted, or the plane can be added to the existing geometry in the domain. A detailed description of the parameters follows: . | Parameter | Description | Type | . | domain | The psDomain object passed in a smart pointer. | psSmartPointer&lt;psDomain&lt;NumericType, D&gt;&gt; | . | gridDelta | Represents the grid spacing or resolution used in the simulation. | NumericType | . | xExtent | Defines the extent of the plane geometry in the x-direction. | NumericType | . | yExtent | Defines the extent of the plane geometry in the y-direction. | NumericType | . | height | Sets the position of the plane in y(2D)/z(3D) direction. | NumericType | . | periodicBoundary | (Optional) If set to true, enables periodic boundaries in both x and y directions. Default is set to false. | bool | . | material | (Optional) Specifies the material used for the plane. Default is set to psMaterial::None. | psMaterial | . Example usage: . | Creating a new domain: | . C++ . auto domain = psSmartPointer&lt;psDomain&lt;NumericType, D&gt;&gt;::New(); psMakePlane&lt;NumericType, D&gt;(domain, 0.5, 10.0, 10.0, 0.0, false, psMaterial::Si).apply(); . Python . domain = vps.Domain() vps.MakePlane(domain=domain, gridDelta=0.5, xExtent=10.0, yExtent=10.0, height=0.0, periodicBoundary=False, material=vps.Material.Si, ).apply() . | Adding plane to existing domain | . C++ . auto domain = psSmartPointer&lt;psDomain&lt;NumericType, D&gt;&gt;::New(); psMakePlane&lt;NumericType, D&gt;(domain, 10.0, psMaterial::Si).apply(); . Python . domain = vps.Domain() vps.MakePlane(domain=domain, height=0.0, material=vps.Material.Si, ).apply() . ",
    "url": "/geo/basic/plane.html",
    
    "relUrl": "/geo/basic/plane.html"
  },"72": {
    "doc": "Plasma Damage",
    "title": "Plasma Damage",
    "content": "#include &lt;psPlasmaDamage.hpp&gt; . Coming soon . ",
    "url": "/models/prebuilt/plasmaDamage.html#plasma-damage",
    
    "relUrl": "/models/prebuilt/plasmaDamage.html#plasma-damage"
  },"73": {
    "doc": "Plasma Damage",
    "title": "Related Examples",
    "content": ". | Volume Model | . ",
    "url": "/models/prebuilt/plasmaDamage.html#related-examples",
    
    "relUrl": "/models/prebuilt/plasmaDamage.html#related-examples"
  },"74": {
    "doc": "Plasma Damage",
    "title": "Plasma Damage",
    "content": " ",
    "url": "/models/prebuilt/plasmaDamage.html",
    
    "relUrl": "/models/prebuilt/plasmaDamage.html"
  },"75": {
    "doc": "Point Data",
    "title": "Point Data",
    "content": ". The psPointData class is designed to hold data associated with points in space. It’s a generic class that can work with any data type T that satisfies the lsConcepts::IsFloatingPoint concept. By default, it uses double as the data type. Member Types: . | ScalarDataType: A type alias for a vector of T type elements. This is used to represent scalar data. | VectorDataType: A type alias for a vector of arrays, each containing 3 elements of T type. This is used to represent vector data. | . Public Methods: . | insertNextScalarData: This method inserts a new scalar data its corresponding label. | . ",
    "url": "/misc/pointData.html",
    
    "relUrl": "/misc/pointData.html"
  },"76": {
    "doc": "Single Particle Process",
    "title": "Single Particle Process",
    "content": "#include &lt;psSingleParticleProcess.hpp&gt; . The single particle process is a simple process model that simulates either etching or deposition, assuming a single particle species. The process is specified by the rate, the particle sticking coefficient, and the exponent in the power cosine distribution of the initial particle directions. The rate can be either negative or positive, corresponding to etching or deposition, respectively. The sticking coefficient is the probability that a particle will stick to the surface upon impact, thus controlling the number of diffusive reflections from the surface. The exponent in the power cosine distribution of the initial particle directions is a measure of the angular spread of the initial particle directions. A higher exponent corresponds to a more focused beam of particles. Additionally, mask materials can be specified, where the rate is assumed to be zero. ",
    "url": "/models/prebuilt/singleParticle.html",
    
    "relUrl": "/models/prebuilt/singleParticle.html"
  },"77": {
    "doc": "Single Particle Process",
    "title": "Implementation",
    "content": "psSingleParticleProcess(const NumericType rate = 1., const NumericType stickingProbability = 1., const NumericType sourceDistributionPower = 1., const psMaterial maskMaterial = psMaterial::None) psSingleParticleProcess(const NumericType rate, const NumericType stickingProbability, const NumericType sourceDistributionPower, const std::vector&lt;psMaterial&gt; maskMaterials) . | Parameter | Description | Default Value | . | rate | Rate of the single particle process | 1.0 | . | stickingProbability | Sticking probability of particles | 1.0 | . | sourceDistributionPower | Power of the power cosine source distribution | 1.0 | . | maskMaterial | Mask material | psMaterial::None | . Example usage: . C++ ... // for a single mask material auto model = psSmartPointer&lt;psSingleParticleProcess&lt;NumericType, D&gt;&gt;::New(1., 0.1, 1., maskMaterial); ... // for multiple mask materials auto model = psSmartPointer&lt;psSingleParticleProcess&lt;NumericType, D&gt;&gt;::New(1., 0.1, 1., {mask1, mask2}); ... Python ... model = vps.SingleParticleProcess(rate=1., stickingProbability=0.1, sourceExponent=1., maskMaterials=[maskMaterial]) ... ",
    "url": "/models/prebuilt/singleParticle.html#implementation",
    
    "relUrl": "/models/prebuilt/singleParticle.html#implementation"
  },"78": {
    "doc": "Single Particle Process",
    "title": "Related Examples",
    "content": ". | Trench Deposition | . ",
    "url": "/models/prebuilt/singleParticle.html#related-examples",
    
    "relUrl": "/models/prebuilt/singleParticle.html#related-examples"
  },"79": {
    "doc": "Primary Source Direction",
    "title": "Primary Source Direction",
    "content": ". The primary source direction is an optional parameter that allows users to tailor the initial particle direction distribution by specifying a tilt during flux calculation from a source plane. In cases where no primary source direction is explicitly defined, it defaults to being aligned with the surface normal of the source plane. If there is no intention to tilt the initial distribution, it is advisable not to set the primary source direction equal to the source plane normal. Instead, using the default value is recommended for a slight performance advantage. Example usage: . auto myModel = psSmartPointer&lt;psProcessModel&lt;NumericType, D&gt;&gt;::New(); double tiltingAngle = 30. * M_PI / 180.; // tilting angle of 30 degree double x = -std::sin(tiltingAngle); double y = -std::cos(tiltingAngle); myModel-&gt;setPrimaryDirection({x, y, -1.}); . ",
    "url": "/models/custom/sourceDirection.html",
    
    "relUrl": "/models/custom/sourceDirection.html"
  },"80": {
    "doc": "Stack Geometry",
    "title": "Stack Geometry",
    "content": "#include &lt;psMakeStack.hpp&gt; . The psMakeStack generates a stack of alternating SiO2/Si3N4 layers featuring an optionally etched hole (3D) or trench (2D) at the center. The stack emerges in the positive z direction (3D) or y direction (2D) and is centered around the origin, with its x/y extent specified. Users have the flexibility to introduce periodic boundaries in the x and y directions. Additionally, the stack can incorporate a top mask with a central hole of a specified radius or a trench with a designated width. This versatile functionality enables users to create diverse and customized structures for simulation scenarios. psMakeStack(psDomainType domain, const NumericType gridDelta, const NumericType xExtent, const NumericType yExtent, const int numLayers, const NumericType layerHeight, const NumericType substrateHeight, const NumericType holeRadius, const NumericType trenchWidth, const NumericType maskHeight, const bool periodicBoundary = false) . | Parameter | Description | Type | . | domain | Specifies the domain type for the stack geometry. | psSmartPointer&lt;psDomain&lt;NumericType, D&gt;&gt; | . | gridDelta | Represents the grid spacing or resolution used in the simulation. | NumericType | . | xExtent | Defines the extent of the stack geometry in the x-direction. | NumericType | . | yExtent | Specifies the extent of the stack geometry in the y-direction. | NumericType | . | numLayers | Sets the number of layers in the stack. | int | . | layerHeight | Determines the height of each layer in the stack. | NumericType | . | substrateHeight | Specifies the height of the substrate. | NumericType | . | holeRadius | Sets the radius of the hole. | NumericType | . | trenchWidth | Determines the width of the trench. | NumericType | . | maskHeight | Specifies the height of the mask. | NumericType | . | periodicBoundary | (Optional) If set to true, enables periodic boundaries. Default is set to false. | bool | . trenchWidth and holeRadius can only be used mutually exclusive. I.e., if one is set, the other has to be set to 0. Example usage: . C++ . auto domain = psSmartPointer&lt;psDomain&lt;NumericType, D&gt;&gt;::New(); psMakeStack&lt;NumericType, D&gt;(domain, 0.5, 10.0, 10.0, 5, 5.0, 10., 0.0, 5.0, 0.0, false) .apply(); . Python . domain = vps.Domain() vps.MakeStack(domain=domain, gridDelta=0.5, xExtent=10.0, yExtent=10.0, numLayers=5, layerHeight=5.0, substrateHeight=10.0, holeRadius=0.0, trenchWidth=5.0, maskHeight=0.0, periodicBoundary=False, ).apply() . ",
    "url": "/geo/basic/stack.html",
    
    "relUrl": "/geo/basic/stack.html"
  },"81": {
    "doc": "Surface Mesh",
    "title": "Surface Mesh",
    "content": ". Documentation Coming soon . Example usage: . C++ . auto domain = psSmartPointer&lt;psDomain&lt;NumericType, D&gt;&gt;::New(); ... // create geometry in domain ... domain-&gt;saveSurfaceMesh(\"fileName\", true); . Python: . domain = vps.Domain() ... # create geometry in domain ... domain.saveSurfaceMesh(fileName=\"fileName\", addMaterialIds=True) . ",
    "url": "/output/surface.html",
    
    "relUrl": "/output/surface.html"
  },"82": {
    "doc": "Surface and Material Interfaces",
    "title": "Surface and Material Interfaces",
    "content": ". The surface, as well as the material interfaces, are described implicitly by a level set (LS) function $\\phi(\\vec{x})$ which is defined at every point $\\vec{x}$ in space. This function is obtained using signed distance transforms, describing the surface $S$ as the zero LS: . \\[S = \\{\\vec{x}\\!: \\, \\phi(\\vec{x}) = 0 \\}.\\] For a more detailed description of the Level-Set method, please refer to one of the following sources1. If the domain contains multiple LSs, the top LS wraps the entire structure and therefore represents the surface, while all other LS functions just describe material interfaces. Formally, the different material regions can be described by ${M}$ LS functions satisfying . \\[\\Phi_k(\\vec{x}) \\leq 0 \\quad \\Leftrightarrow \\quad \\vec{x} \\in \\bigcup_{i=1}^k \\mathcal{M}_i.\\] Here $\\Phi_M$ describes the entire structure $\\mathcal{M}$, and the other LS functions correspond to material interfaces. When inserting a new LS into the domain, an automatic wrapping process ensues. This process involves enveloping all existing Level-Sets through a Boolean operation, specifically a union with the topmost LS. It’s worth noting, though, that this default behavior is not obligatory. In instances where a specialized domain structure is desired, users have the option to circumvent this automatic wrapping mechanism. Coming soon . | Source &#8617; . | . ",
    "url": "/domain/surface.html#surface-and-material-interfaces",
    
    "relUrl": "/domain/surface.html#surface-and-material-interfaces"
  },"83": {
    "doc": "Surface and Material Interfaces",
    "title": "Surface and Material Interfaces",
    "content": " ",
    "url": "/domain/surface.html",
    
    "relUrl": "/domain/surface.html"
  },"84": {
    "doc": "Surface Model",
    "title": "Surface Model",
    "content": ". ",
    "url": "/models/custom/surfaceModel.html",
    
    "relUrl": "/models/custom/surfaceModel.html"
  },"85": {
    "doc": "Surface Model",
    "title": "Summary",
    "content": ". | The psSurfaceModel class is used to describe surface reactions, combining particle fluxes with the surface chemical reactions. | The velocities used for surface advection in a time step are calculated through the calculateVelocities() function. | Surface coverages can be used to track the coverage a chemical species on the surface through a time step. | The coverages can be initialized to equilibrium by iteratively calculating the fluxes on the surface and updating the coverages. The number of iterations to initialize the coverages can be specified through the psProcess. | Coverages and fluxes are stored as psPointData. | . The psSurfaceModel class serves as a comprehensive framework for detailing surface chemistries. Users have the flexibility to create a customized child class where they can precisely dictate how surface coverages evolve, driven by the rates at which particles impact the surface. One key feature is the capability to monitor surface coverages, providing insights into the presence of chemical species on the surface throughout a simulation’s time step. To initialize the coverage data vector, the method initializeCoverages() is employed. void initializeCoverages(unsigned numSurfacePoints) override { // a single set of coverages is initialized here std::vector&lt;NumericType&gt; someCoverage(numSurfacePoints, 0); coverages = psSmartPointer&lt;psPointData&lt;NumericType&gt;&gt;::New(); coverages-&gt;insertNextScalarData(someCoverage, \"someCoverage\"); } . To use coverages, it is essential to initialize the class member coverages with a new instance of psPointData. If the coverages variable is left as nullptr, no coverages will be utilized during the simulation. To initialize a single coverage, a container with a size equal to the number of surface points must be created and inserted into the psPointData. Additionally, a name for the coverage can be specified during initialization. This designated name should then be used in updateCoverages() or calculateVelocities() to access the specific coverage as needed. To ensure accurate representations, coverages can be initialized to equilibrium by iteratively calculating surface fluxes and updating coverages. The initialization process’s iteration count is customizable through the psProcess interface. The method updateCoverages() encapsulates the user-defined description of surface coverage evolution in each iteration. Since coverages is a member of the psSurfaceModel class, it can be accessed in every member function. void updateCoverages(psSmartPointer&lt;psPointData&lt;NumericType&gt;&gt; particleFluxes, const std::vector&lt;NumericType&gt; &amp;materialIds) override { auto myCoverage = coverages-&gt;getScalarData(\"someCoverage\"); // update coverage from calculated fluxes } . Within the psSurfaceModel class, the method calculateVelocities() utilizes fluxes obtained through ray tracing, to provide the velocities used for surface advection in a time step. Here the fluxes from particle, as well as previously calculated coverages can be accessed and combined to yield the final velocity at each surface point. The function should return a psSmartPointer to a new vector, containing the velocity at each surface point. In order to create a custom surface the user has to interface the psSurfaceModel class. An example implementation of a custom surface model is given below: . template &lt;typename NumericType&gt; class myCustomSurfaceModel : public psSurfaceModel&lt;NumericType&gt; { public: using psSurfaceModel&lt;NumericType&gt;::coverages; // needed to access coverages void initializeCoverages(unsigned numSurfacePoints) override { // a single set of coverages is initialized here std::vector&lt;NumericType&gt; someCoverage(numSurfacePoints, 0); coverages = psSmartPointer&lt;psPointData&lt;NumericType&gt;&gt;::New(); coverages-&gt;insertNextScalarData(someCoverage, \"someCoverage\"); } void updateCoverages(psSmartPointer&lt;psPointData&lt;NumericType&gt;&gt; particleFluxes, const std::vector&lt;NumericType&gt; &amp;materialIds) override { auto myCoverage = coverages-&gt;getScalarData(\"someCoverage\"); // update coverage from calculated fluxes } psSmartPointer&lt;std::vector&lt;NumericType&gt;&gt; calculateVelocities( psSmartPointer&lt;psPointData&lt;NumericType&gt;&gt; rates, const std::vector&lt;std::array&lt;NumericType, 3&gt;&gt; &amp;coordinates, const std::vector&lt;NumericType&gt; &amp;materialIds) override { // use coverages and rates here to calculate the velocity here return psSmartPointer&lt;std::vector&lt;NumericType&gt;&gt;::New( *rates-&gt;getScalarData(\"particleRate\")); } }; . ",
    "url": "/models/custom/surfaceModel.html#summary",
    
    "relUrl": "/models/custom/surfaceModel.html#summary"
  },"86": {
    "doc": "Trench Geometry",
    "title": "Trench Geometry",
    "content": "#include &lt;psMakeTrench.hpp&gt; . The psMakeTrench class is used to generate a new trench geometry extending in the z (3D) or y (2D) direction, centrally positioned at the origin with the total extent specified in the x and y directions. The trench configuration may include periodic boundaries in both the x and y directions. Users have the flexibility to define the trench’s width, depth, and incorporate tapering with a designated angle. Moreover, the trench can serve as a mask, applying the specified material exclusively to the bottom while the remaining portion adopts the mask material. psMakeTrench(psDomainType domain, const NumericType gridDelta, const NumericType xExtent, const NumericType yExtent, const NumericType trenchWidth, const NumericType trenchDepth, const NumericType taperingAngle = 0., // in degrees const NumericType baseHeight = 0., const bool periodicBoundary = false, const bool makeMask = false, const psMaterial material = psMaterial::None) . | Parameter | Description | Type | . | domain | Specifies the type of domain for the trench geometry. | psSmartPointer&lt;psDomain&lt;NumericType, D&gt;&gt; | . | gridDelta | Represents the grid spacing or resolution used in the simulation. | NumericType | . | xExtent | Defines the extent of the trench geometry in the x-direction. | NumericType | . | yExtent | Specifies the extent of the trench geometry in the y-direction. | NumericType | . | trenchWidth | Sets the width of the trench. | NumericType | . | trenchDepth | Determines the depth of the trench. | NumericType | . | taperingAngle | (Optional) Specifies the angle of tapering for the trench geometry in degrees. Default is set to 0. | NumericType | . | baseHeight | (Optional) Sets the base height of the trench. Default is set to 0. | NumericType | . | periodicBoundary | (Optional) If set to true, enables periodic boundaries in both x and y directions (only applicable in 3D). Default is set to false. | bool | . | makeMask | (Optional) If set to true, allows the trench to function as a mask, with specified material applied only to the bottom. Default is set to false. | bool | . | material | (Optional) Specifies the material used for the trench. Default is set to psMaterial_None. | psMaterial | . Example usage: . C++ . auto domain = psSmartPointer&lt;psDomain&lt;NumericType, D&gt;&gt;::New(); psMakeTrench&lt;NumericType, D&gt;(domain, 0.5, 10.0, 10.0, 5.0, 5.0, 10., 0., false, false, psMaterial::Si) .apply(); . Python . domain = vps.Domain() vps.MakeTrench(domain=domain, gridDelta=0.5, xExtent=10.0, yExtent=10.0, trenchWidth=5.0, trenchDepth=5.0, taperingAngle=10.0, baseHeight=0.0, periodicBoundary=False, makeMask=False, material=vps.Material.Si, ).apply() . ",
    "url": "/geo/basic/trench.html",
    
    "relUrl": "/geo/basic/trench.html"
  },"87": {
    "doc": "Velocity Field",
    "title": "Velocity Field",
    "content": ". Coming soon . ",
    "url": "/models/custom/velocityField.html",
    
    "relUrl": "/models/custom/velocityField.html"
  },"88": {
    "doc": "Velocity Field",
    "title": "Surface Velocity Extension",
    "content": "| Option | Description | . | 0 | Do not translate level set ID to surface ID. This should be enabled if the surface velocity is only provided in the psVelocityField class and not through the psSurfaceModel class. | . | 1 | Use unordered map to translate level set ID to surface ID. | . | 2 | Use KD-tree to translate level set ID to surface ID. The KD-tree uses a nearest neighbor lookup to determine the closest surface point and according velocity. | . ",
    "url": "/models/custom/velocityField.html#surface-velocity-extension",
    
    "relUrl": "/models/custom/velocityField.html#surface-velocity-extension"
  },"89": {
    "doc": "Volume Mesh",
    "title": "Volume Mesh",
    "content": ". Documentation Coming soon . Example usage: . C++ . auto domain = psSmartPointer&lt;psDomain&lt;NumericType, D&gt;&gt;::New(); ... // create geometry in domain ... domain-&gt;saveVolumeMesh(\"fileName\"); . Python: . domain = vps.Domain() ... # create geometry in domain ... domain.saveVolumeMesh(fileName=\"fileName\") . ",
    "url": "/output/volume.html",
    
    "relUrl": "/output/volume.html"
  },"90": {
    "doc": "Volume",
    "title": "Volume",
    "content": ". A Cell-Set (CS) is used to store and track volume information in the domain. The CS is stored over the whole simulation domain, above and/or below the surface described by the Level-Set. It uses the same grid as the Level-Set, such that each Level-Set grid point acts as the corner of the cells around the point. To determine which material region a cell lies in, the LS values at the cell corner of the material interface are inspected. If the sum of the values is negative the cell belongs to the underlying material, otherwise it represents the material on the other side of the interface. To find a cell in which an arbitrary point in space resides, a bounding volume hierarchy (BVH) is built on top of the CS. This allows for fast access to random cells in the CS. Additionally, cell-neighbor relations are established when setting up the CS. This allows for quick access to neighbor cells. ",
    "url": "/domain/volume.html",
    
    "relUrl": "/domain/volume.html"
  },"91": {
    "doc": "Volume",
    "title": "How to use the Cell-Set",
    "content": "To generate the CS from your domain, use the function: . auto domain = psSmartPointer&lt;psDomain&lt;NumericType, D&gt;&gt;::New() ... // Add level-sets to domain ... domain-&gt;generateCellSet(position, isCellSetAboveSurface) . The position parameter describes the location of the cell set surface. With the parameter isCellSetAboveSurface one can specify whether the Cell-Set should be placed above or below the surface. If the Cell-Set is above the surface it covers all material in the domain and the position parameter should be set higher than the highest surface point in the domain. ",
    "url": "/domain/volume.html#how-to-use-the-cell-set",
    
    "relUrl": "/domain/volume.html#how-to-use-the-cell-set"
  },"92": {
    "doc": "Volume",
    "title": "Related Examples",
    "content": ". | Volume Model | Oxide Regrowth | . ",
    "url": "/domain/volume.html#related-examples",
    
    "relUrl": "/domain/volume.html#related-examples"
  }
}
